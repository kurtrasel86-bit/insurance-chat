# Анализ файлов проекта и чата
_Exported on 10/1/2025 at 18:35:31 GMT+7 from Cursor (1.6.35)_

---

**User**

проанализируй файлы проекта и старый чат (cursor_.md) и давай продолжим работу

---

**Cursor**

Я проанализирую файлы проекта и старый чат, чтобы понять контекст и продолжить работу.

Отлично! Я проанализировал проект. Вижу, что вы работаете над **системой страхования с чат-ботом** на NestJS + Telegram. По истории чата последнее, что было сделано:

✅ NestJS сервер с модульной архитектурой
✅ JWT аутентификация для агентов
✅ Telegram webhook интеграция
✅ AI автоответы через OpenAI
✅ Схема БД с Prisma (SQLite)

Давайте посмотрю текущее состояние ключевых файлов:

Понял ситуацию! У вас есть:

✅ **Работающий Telegram бот** с AI автоответами  
✅ **Схема БД** в Prisma (готова, но не подключена)  
✅ **In-memory хранилище** в ChatService (нужно мигрировать на БД)

**Следующие логичные шаги:**

1. **Подключить Prisma** и мигрировать на реальную БД
2. **Сохранять историю чатов** в базу данных
3. **Реализовать Knowledge Base** для умных ответов (RAG)
4. **Добавить веб-виджет** для сайта
5. **Создать админ-панель** для агентов

**Что предлагаю сделать сейчас:**

Давайте сначала **подключим Prisma и мигрируем ChatService на реальную БД**, чтобы данные сохранялись между перезапусками. Это фундамент для дальнейшей работы.

Проверю, что у нас есть:

Вижу картину! У вас:
- ✅ Prisma установлена (в package.json)
- ✅ Схема БД готова (schema.prisma)
- ❌ Нет `.env` файла
- ❌ БД не инициализирована
- ❌ Prisma Client не сгенерирован

Давайте подключим Prisma и мигрируем на реальную БД. Создам план:

Файл `.env` заблокирован для безопасности. **Вам нужно создать его вручную:**

**Создайте файл** `insurance-chat/backend/.env` **со следующим содержимым:**

```env
DATABASE_URL="file:./dev.db"

TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"

# Опционально - для OpenAI
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o-mini"

JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"
```

А пока я исправлю ошибку в схеме Prisma и подготовлю все для подключения БД:

```plaintext
DATABASE_URL="file:./dev.db"

TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"

# Опционально - для OpenAI
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o-mini"

JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"
```

```plaintext
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid())
  channel       String
  channelUserId String
  consent       Boolean  @default(false)
  preferVoice   Boolean  @default(false)
  email         String?  @unique
  sessions      ChatSession[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Agent {
  id        String   @id @default(uuid())
  name      String
  login     String   @unique
  password  String
  status    String   @default("offline")
  companies String
  sessions  ChatSession[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChatSession {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  agent       Agent?   @relation(fields: [agentId], references: [id])
  agentId     String?
  state       String   @default("qa")
  preferVoice Boolean  @default(false)
  email       String?
  messages    Message[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Message {
  id        String   @id @default(uuid())
  session   ChatSession @relation(fields: [sessionId], references: [id])
  sessionId String
  sender    String
  text      String?
  voiceUrl  String?
  fileUrl   String?
  createdAt DateTime @default(now())
}

model Policy {
  id            String   @id @default(uuid())
  sessionId     String
  productType   String
  companyCode   String
  status        String
  pdfUrl        String?
  expireAt      DateTime?
  isAgentClient Boolean @default(false)
  createdAt     DateTime @default(now())
}

model Reminder {
  id         String   @id @default(uuid())
  policyId   String
  remindAt   DateTime
  recipients String
  status     String   @default("pending")
  createdAt  DateTime @default(now())
}

model KBDoc {
  id          String   @id @default(uuid())
  companyCode String
  productCode String
  title       String
  fileUrl     String?
  sourceUrl   String?
  version     String?
  chunks      KBChunk[]
  createdAt   DateTime @default(now())
}

model KBChunk {
  id       String  @id @default(uuid())
  doc      KBDoc   @relation(fields: [docId], references: [id])
  docId    String
  chunkIdx Int
  text     String
}

model Incident {
  id        String   @id @default(uuid())
  sessionId String?
  type      String
  details   String
  createdAt DateTime @default(now())
}
```

Теперь создам Prisma модуль для подключения к БД:

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}

```

```typescript
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

```

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ChatModule } from './modules/chat/chat.module';
import { AuthModule } from './modules/auth/auth.module';
import { ChannelsModule } from './modules/channels/channels.module';
import { PrismaModule } from './modules/prisma/prisma.module';

@Module({
  imports: [PrismaModule, ChatModule, AuthModule, ChannelsModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateSessionDto, Message, PostMessageDto, Session } from './chat.dtos';

@Injectable()
export class ChatService {
  constructor(private readonly prisma: PrismaService) {}

  async createSession(dto: CreateSessionDto): Promise<Session> {
    // First, find or create user
    let user = await this.prisma.user.findFirst({
      where: {
        channel: dto.channel,
        channelUserId: dto.channelUserId,
      },
    });

    if (!user) {
      user = await this.prisma.user.create({
        data: {
          channel: dto.channel,
          channelUserId: dto.channelUserId,
          preferVoice: dto.preferVoice ?? false,
          email: dto.email,
        },
      });
    }

    // Create session
    const session = await this.prisma.chatSession.create({
      data: {
        userId: user.id,
        preferVoice: dto.preferVoice ?? false,
        email: dto.email,
      },
    });

    return {
      id: session.id,
      channel: dto.channel,
      channelUserId: dto.channelUserId,
      preferVoice: session.preferVoice,
      email: session.email ?? null,
      createdAt: session.createdAt.toISOString(),
    };
  }

  async getOrCreateSessionForChannel(channel: string, channelUserId: string): Promise<Session> {
    // Find user
    let user = await this.prisma.user.findFirst({
      where: {
        channel,
        channelUserId,
      },
      include: {
        sessions: {
          orderBy: {
            createdAt: 'desc',
          },
          take: 1,
        },
      },
    });

    if (!user) {
      // Create user and session
      user = await this.prisma.user.create({
        data: {
          channel,
          channelUserId,
          sessions: {
            create: {},
          },
        },
        include: {
          sessions: true,
        },
      });
    }

    // Get or create active session
    let session = user.sessions[0];
    if (!session) {
      session = await this.prisma.chatSession.create({
        data: {
          userId: user.id,
        },
      });
    }

    return {
      id: session.id,
      channel: user.channel,
      channelUserId: user.channelUserId,
      preferVoice: session.preferVoice,
      email: session.email ?? null,
      createdAt: session.createdAt.toISOString(),
    };
  }

  async postMessage(dto: PostMessageDto): Promise<Message> {
    const session = await this.prisma.chatSession.findUnique({
      where: { id: dto.sessionId },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    const message = await this.prisma.message.create({
      data: {
        sessionId: dto.sessionId,
        sender: dto.sender,
        text: dto.text,
        voiceUrl: dto.voiceUrl,
        fileUrl: dto.fileUrl,
      },
    });

    return {
      id: message.id,
      sessionId: message.sessionId,
      sender: message.sender,
      text: message.text ?? null,
      voiceUrl: message.voiceUrl ?? null,
      fileUrl: message.fileUrl ?? null,
      createdAt: message.createdAt.toISOString(),
    };
  }

  async getMessages(sessionId: string) {
    const session = await this.prisma.chatSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    const messages = await this.prisma.message.findMany({
      where: { sessionId },
      orderBy: { createdAt: 'asc' },
    });

    return {
      items: messages.map((m) => ({
        id: m.id,
        sessionId: m.sessionId,
        sender: m.sender,
        text: m.text ?? null,
        voiceUrl: m.voiceUrl ?? null,
        fileUrl: m.fileUrl ?? null,
        createdAt: m.createdAt.toISOString(),
      })),
    };
  }
}



```

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { ChatService } from '../chat/chat.service';
import { AiService } from '../ai/ai.service';

type TelegramMessage = {
  message?: { message_id: number; chat: { id: number }; from?: { id: number; username?: string }; text?: string };
  edited_message?: { message_id: number; chat: { id: number }; from?: { id: number; username?: string }; text?: string };
};

@Controller('channels/telegram')
export class TelegramController {
  constructor(private readonly chat: ChatService, private readonly ai: AiService) {}

  @Post('webhook')
  async webhook(@Body() update: TelegramMessage) {
    const msg = update.message || update.edited_message;
    if (!msg || !msg.text) return { ok: true };
    const channelUserId = String(msg.from?.id ?? msg.chat.id);
    const session = await this.chat.getOrCreateSessionForChannel('telegram', channelUserId);
    await this.chat.postMessage({ sessionId: session.id, sender: 'user', text: msg.text });
    const aiReply = await this.ai.generateReply(msg.text);
    await this.chat.postMessage({ sessionId: session.id, sender: 'ai', text: aiReply });

    // Send reply back to Telegram chat if bot token is configured
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    if (botToken) {
      await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ chat_id: msg.chat.id, text: aiReply }),
      }).catch(() => void 0);
    }

    return { ok: true };
  }
}



```

Отлично! Код мигрирован на Prisma. Теперь создам необходимые скрипты:

```json
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^6.16.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "prisma": "^6.16.2",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

```

```ignore
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Environment variables
.env
.env.local
.env.*.local

# Database
*.db
*.db-journal
/prisma/migrations

```

```markdown
# Настройка проекта Insurance Chat Backend

## 📋 Шаг 1: Создайте .env файл

Создайте файл `.env` в папке `backend` со следующим содержимым:

```env
DATABASE_URL="file:./dev.db"

TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"

# Опционально - для OpenAI
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o-mini"

JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"
```

## 🔧 Шаг 2: Установите зависимости

```powershell
npm install
```

## 🗄️ Шаг 3: Настройте базу данных

### Сгенерировать Prisma Client:
```powershell
npm run prisma:generate
```

### Создать миграцию БД:
```powershell
npm run prisma:migrate
```

При запросе имени миграции введите: `init`

## 🚀 Шаг 4: Запустите сервер

```powershell
npm run start:dev
```

## 🌐 Настройка Telegram Webhook (для локальной разработки)

### Окно №1 - Запустите туннель:
```powershell
npx localtunnel --port 3000
```

Скопируйте URL туннеля (например: `https://tangy-colts-change.loca.lt`)

### Окно №2 - Настройте webhook:
```powershell
$botToken = "8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
$publicUrl = "https://ваш-url.loca.lt"  # Вставьте URL из окна №1
Invoke-RestMethod -Uri ("https://api.telegram.org/bot{0}/setWebhook?url={1}/channels/telegram/webhook" -f $botToken, $publicUrl) -Method Get
```

### Окно №3 - Запустите сервер:
```powershell
cd backend
npm run start:dev
```

## 🛠️ Дополнительные команды

### Просмотр БД через Prisma Studio:
```powershell
npm run prisma:studio
```

### Пересоздание БД:
```powershell
# Удалите файл dev.db и папку prisma/migrations
# Затем запустите снова:
npm run prisma:migrate
```

## ✅ Проверка работы

1. Откройте Telegram бота
2. Напишите любое сообщение
3. Бот должен ответить
4. Сообщения сохраняются в БД (`dev.db`)

## 📚 Структура проекта

```
backend/
├── src/
│   ├── modules/
│   │   ├── ai/         # AI сервис (OpenAI)
│   │   ├── auth/       # Аутентификация агентов
│   │   ├── channels/   # Telegram webhook
│   │   ├── chat/       # Чат сервис
│   │   └── prisma/     # Prisma подключение
│   └── main.ts
├── prisma/
│   └── schema.prisma   # Схема БД
├── .env               # Переменные окружения
└── dev.db            # SQLite база данных
```

## 🔍 Troubleshooting

### Ошибка: "Prisma Client not generated"
```powershell
npm run prisma:generate
```

### Ошибка: "Can't reach database"
- Проверьте, что `.env` файл создан
- Проверьте путь в `DATABASE_URL`

### Webhook не работает
- Убедитесь, что туннель запущен
- Проверьте, что URL туннеля правильный в webhook
- Проверьте логи сервера на наличие ошибок

```

Perfect! Я завершил миграцию на Prisma БД. Вот что было сделано:

## ✅ Выполнено:

### 1. **Подключение Prisma к проекту**
   - ✅ Исправлена схема БД (добавлена связь `KBDoc.chunks`)
   - ✅ Создан `PrismaModule` и `PrismaService` для подключения к БД
   - ✅ Добавлен в `AppModule` как глобальный модуль

### 2. **Миграция ChatService на БД**
   - ✅ Переписан `ChatService` с in-memory на Prisma
   - ✅ Добавлена логика автоматического создания User и Session
   - ✅ Все методы теперь асинхронные и работают с реальной БД
   - ✅ Обновлен `TelegramController` для работы с async методами

### 3. **Настройка проекта**
   - ✅ Добавлены Prisma скрипты в `package.json`
   - ✅ Создан `.gitignore` для исключения БД и .env
   - ✅ Создан `SETUP.md` с полной инструкцией по настройке

---

## 📋 Что нужно сделать СЕЙЧАС:

### **Шаг 1:** Создайте `.env` файл
Создайте файл `insurance-chat/backend/.env`:
```env
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
JWT_SECRET="your-super-secret-jwt-key"
```

### **Шаг 2:** Инициализируйте БД
Откройте **PowerShell** и выполните:

```powershell
cd insurance-chat\backend
npm install
npm run prisma:generate
npm run prisma:migrate
```

При запросе имени миграции введите: **`init`**

### **Шаг 3:** Запустите сервер
```powershell
npm run start:dev
```

---

## 🚀 Следующие шаги развития проекта:

После того как БД заработает, можно добавить:

1. **Knowledge Base (RAG)** - умные ответы на основе базы знаний о страховых продуктах
2. **Веб-виджет** - чат для встраивания на сайт
3. **Админ-панель** - интерфейс для агентов для управления чатами
4. **Handover механизм** - передача чата от AI к живому агенту
5. **Интеграция с polis.online** - оформление полисов прямо из чата

Хотите продолжить с каким-то из этих пунктов? 🎯

```plaintext
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
JWT_SECRET="your-super-secret-jwt-key"
```

```plaintext
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
JWT_SECRET="your-super-secret-jwt-key"
```

```powershell
cd insurance-chat\backend
npm install
npm run prisma:generate
npm run prisma:migrate
```

```powershell
npm run start:dev
```

---

**User**

давай продолжим, выбери сам

---

**Cursor**

Отлично! Я выберу **Knowledge Base с RAG** - это самое важное для страхового бота. Сейчас AI просто использует общие знания, но для страхования нужны точные ответы о конкретных продуктах.

Что я сделаю:
1. **KB Service** - управление базой знаний
2. **Векторный поиск** - семантический поиск по документам
3. **RAG интеграция** - умные ответы на основе документов
4. **Seed данные** - примеры страховых продуктов для тестирования

Начнём! 🚀

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

interface EmbeddingVector {
  embedding: number[];
}

@Injectable()
export class KbService {
  private readonly logger = new Logger(KbService.name);
  private embeddingsCache = new Map<string, number[]>();

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Генерация эмбеддинга через OpenAI
   */
  private async generateEmbedding(text: string): Promise<number[]> {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      this.logger.warn('OPENAI_API_KEY not set, using zero vector');
      return new Array(1536).fill(0); // Default embedding dimension for text-embedding-3-small
    }

    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: 'text-embedding-3-small',
          input: text,
        }),
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = (await response.json()) as { data: EmbeddingVector[] };
      return data.data[0].embedding;
    } catch (error: any) {
      this.logger.error('Failed to generate embedding', error?.stack || String(error));
      return new Array(1536).fill(0);
    }
  }

  /**
   * Косинусное сходство между векторами
   */
  private cosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) return 0;

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }

    if (normA === 0 || normB === 0) return 0;
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * Добавление документа в базу знаний
   */
  async addDocument(params: {
    companyCode: string;
    productCode: string;
    title: string;
    content: string;
    fileUrl?: string;
    sourceUrl?: string;
    version?: string;
  }): Promise<{ docId: string; chunksCount: number }> {
    const { companyCode, productCode, title, content, fileUrl, sourceUrl, version } = params;

    // Разбиваем документ на чанки (по 500 символов с перекрытием 50)
    const chunks = this.splitIntoChunks(content, 500, 50);

    // Создаём документ
    const doc = await this.prisma.kBDoc.create({
      data: {
        companyCode,
        productCode,
        title,
        fileUrl,
        sourceUrl,
        version,
      },
    });

    // Создаём чанки
    for (let i = 0; i < chunks.length; i++) {
      await this.prisma.kBChunk.create({
        data: {
          docId: doc.id,
          chunkIdx: i,
          text: chunks[i],
        },
      });
    }

    this.logger.log(`Added document ${doc.id} with ${chunks.length} chunks`);

    return {
      docId: doc.id,
      chunksCount: chunks.length,
    };
  }

  /**
   * Разбиение текста на чанки
   */
  private splitIntoChunks(text: string, chunkSize: number, overlap: number): string[] {
    const chunks: string[] = [];
    let start = 0;

    while (start < text.length) {
      const end = Math.min(start + chunkSize, text.length);
      chunks.push(text.substring(start, end));
      start += chunkSize - overlap;
    }

    return chunks;
  }

  /**
   * Семантический поиск по базе знаний
   */
  async search(params: {
    query: string;
    companyCode?: string;
    productCode?: string;
    limit?: number;
  }): Promise<Array<{ text: string; score: number; docTitle: string; companyCode: string; productCode: string }>> {
    const { query, companyCode, productCode, limit = 5 } = params;

    // Генерируем эмбеддинг запроса
    const queryEmbedding = await this.generateEmbedding(query);

    // Получаем все чанки (с фильтром по компании/продукту если указано)
    const chunks = await this.prisma.kBChunk.findMany({
      include: {
        doc: true,
      },
      where: {
        doc: {
          ...(companyCode && { companyCode }),
          ...(productCode && { productCode }),
        },
      },
    });

    // Если чанков нет, возвращаем пустой результат
    if (chunks.length === 0) {
      return [];
    }

    // Генерируем эмбеддинги для чанков и вычисляем сходство
    const results = await Promise.all(
      chunks.map(async (chunk) => {
        const cacheKey = `${chunk.id}`;
        let chunkEmbedding = this.embeddingsCache.get(cacheKey);

        if (!chunkEmbedding) {
          chunkEmbedding = await this.generateEmbedding(chunk.text);
          this.embeddingsCache.set(cacheKey, chunkEmbedding);
        }

        const score = this.cosineSimilarity(queryEmbedding, chunkEmbedding);

        return {
          text: chunk.text,
          score,
          docTitle: chunk.doc.title,
          companyCode: chunk.doc.companyCode,
          productCode: chunk.doc.productCode,
        };
      }),
    );

    // Сортируем по сходству и возвращаем топ результатов
    return results.sort((a, b) => b.score - a.score).slice(0, limit);
  }

  /**
   * Получение всех документов
   */
  async listDocuments(params?: { companyCode?: string; productCode?: string }) {
    return this.prisma.kBDoc.findMany({
      where: {
        ...(params?.companyCode && { companyCode: params.companyCode }),
        ...(params?.productCode && { productCode: params.productCode }),
      },
      include: {
        _count: {
          select: { chunks: true },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }

  /**
   * Удаление документа
   */
  async deleteDocument(docId: string) {
    // Удаляем чанки
    await this.prisma.kBChunk.deleteMany({
      where: { docId },
    });

    // Удаляем документ
    await this.prisma.kBDoc.delete({
      where: { id: docId },
    });

    // Очищаем кеш эмбеддингов
    this.embeddingsCache.clear();

    this.logger.log(`Deleted document ${docId}`);
  }
}

```

```typescript
import { Module } from '@nestjs/common';
import { KbService } from './kb.service';
import { KbController } from './kb.controller';

@Module({
  providers: [KbService],
  controllers: [KbController],
  exports: [KbService],
})
export class KbModule {}

```

```typescript
import { Body, Controller, Delete, Get, Param, Post, Query } from '@nestjs/common';
import { KbService } from './kb.service';

@Controller('kb')
export class KbController {
  constructor(private readonly kb: KbService) {}

  /**
   * POST /kb/documents - Добавить документ
   */
  @Post('documents')
  async addDocument(
    @Body()
    body: {
      companyCode: string;
      productCode: string;
      title: string;
      content: string;
      fileUrl?: string;
      sourceUrl?: string;
      version?: string;
    },
  ) {
    return this.kb.addDocument(body);
  }

  /**
   * GET /kb/documents - Список документов
   */
  @Get('documents')
  async listDocuments(@Query('companyCode') companyCode?: string, @Query('productCode') productCode?: string) {
    return this.kb.listDocuments({ companyCode, productCode });
  }

  /**
   * DELETE /kb/documents/:id - Удалить документ
   */
  @Delete('documents/:id')
  async deleteDocument(@Param('id') id: string) {
    await this.kb.deleteDocument(id);
    return { success: true };
  }

  /**
   * POST /kb/search - Поиск по базе знаний
   */
  @Post('search')
  async search(
    @Body()
    body: {
      query: string;
      companyCode?: string;
      productCode?: string;
      limit?: number;
    },
  ) {
    return this.kb.search(body);
  }
}

```

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ChatModule } from './modules/chat/chat.module';
import { AuthModule } from './modules/auth/auth.module';
import { ChannelsModule } from './modules/channels/channels.module';
import { PrismaModule } from './modules/prisma/prisma.module';
import { KbModule } from './modules/kb/kb.module';

@Module({
  imports: [PrismaModule, ChatModule, AuthModule, ChannelsModule, KbModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { KbService } from '../kb/kb.service';

@Injectable()
export class AiService {
  private readonly logger = new Logger(AiService.name);

  constructor(private readonly kb: KbService) {}

  async generateReply(userText: string, options?: { useRAG?: boolean }): Promise<string> {
    const apiKey = process.env.OPENAI_API_KEY;
    const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
    const useRAG = options?.useRAG ?? true; // По умолчанию используем RAG

    // Fallback: simple heuristic answer if no API key configured
    if (!apiKey) {
      return `Понял запрос: "${userText}". Сейчас это тестовый автоответ. Уточните, пожалуйста, что именно хотите оформить или узнать по страхованию?`;
    }

    try {
      let systemPrompt = 'Ты страховой ассистент для китайских страховых компаний. Отвечай кратко и по делу, дружелюбно, на русском.';
      let context = '';

      // RAG: Поиск релевантной информации в базе знаний
      if (useRAG) {
        const results = await this.kb.search({
          query: userText,
          limit: 3,
        });

        if (results.length > 0) {
          context = results
            .map((r, i) => `[Документ ${i + 1}: ${r.docTitle} (${r.companyCode}/${r.productCode})]\n${r.text}`)
            .join('\n\n');

          systemPrompt = `Ты страховой ассистент для китайских страховых компаний. 
Отвечай кратко и по делу, дружелюбно, на русском.
Используй ТОЛЬКО информацию из приведенных документов для ответа.
Если в документах нет нужной информации, честно скажи об этом и предложи связаться с агентом.

=== БАЗА ЗНАНИЙ ===
${context}
===================`;

          this.logger.log(`RAG found ${results.length} relevant chunks for query: "${userText}"`);
        } else {
          this.logger.log(`RAG: no relevant documents found for query: "${userText}"`);
          systemPrompt += '\nВ базе знаний пока нет релевантной информации. Дай общий ответ и предложи связаться с агентом для деталей.';
        }
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model,
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userText },
          ],
          temperature: 0.3,
          max_tokens: 500,
        }),
      });

      if (!response.ok) {
        const text = await response.text();
        this.logger.warn(`OpenAI error: ${response.status} ${text}`);
        return 'Спасибо за вопрос! Сейчас много обращений, уточните, пожалуйста, детали, и я отвечу.';
      }

      const data = (await response.json()) as any;
      const content = data?.choices?.[0]?.message?.content?.trim();
      return content || 'Спасибо за вопрос! Могу уточнить детали, чтобы помочь точнее?';
    } catch (err: any) {
      this.logger.error('AI request failed', err?.stack || String(err));
      return 'Сервис автоответа временно недоступен. Попробуйте спросить иначе или позвать агента.';
    }
  }
}




```

Теперь нужно обновить модуль AI, чтобы он мог использовать KB сервис:

```typescript
import { Module } from '@nestjs/common';
import { TelegramController } from './telegram.controller';
import { ChatModule } from '../chat/chat.module';
import { KbModule } from '../kb/kb.module';
import { AiService } from '../ai/ai.service';

@Module({
  imports: [ChatModule, KbModule],
  controllers: [TelegramController],
  providers: [AiService],
})
export class ChannelsModule {}



```

Отлично! Теперь создам seed данные с примерами страховых продуктов:

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

const sampleDocuments = [
  {
    companyCode: 'PICC',
    productCode: 'TRAVEL_ANNUAL',
    title: 'Годовой страховой полис для туристов в Китай',
    content: `Годовой туристический полис PICC обеспечивает комплексную защиту при поездках в Китай на весь год.

Основные покрытия:
- Медицинские расходы: до 500,000 юаней
- Госпитализация: полное покрытие
- Экстренная эвакуация: включена
- Багаж: до 20,000 юаней
- Отмена поездки: до 50,000 юаней

Стоимость: от 2,500 юаней в год

Особенности:
- Неограниченное количество поездок в год
- Каждая поездка до 90 дней
- Круглосуточная поддержка на русском языке
- Онлайн оформление за 5 минут

Требования:
- Возраст: 18-70 лет
- Российское гражданство
- Действующий загранпаспорт`,
  },
  {
    companyCode: 'CPIC',
    productCode: 'MEDICAL_PREMIUM',
    title: 'Премиум медицинское страхование CPIC',
    content: `Премиум медицинский полис CPIC - максимальная защита здоровья в Китае.

Покрытие:
- Амбулаторное лечение: до 100,000 юаней/год
- Стационарное лечение: до 1,000,000 юаней/год
- Стоматология: до 30,000 юаней/год
- Традиционная китайская медицина: включена
- Плановые осмотры: 2 раза в год бесплатно

Стоимость: от 8,000 юаней в год

Преимущества:
- Прямые расчеты с клиниками (cashless)
- Доступ к лучшим госпиталям Китая
- Личный медицинский координатор
- Телемедицина 24/7 на русском языке
- Покрытие хронических заболеваний

Дополнительные опции:
- Материнство и роды: +3,000 юаней
- Стоматология расширенная: +2,000 юаней
- Зрение (очки, линзы): +1,500 юаней`,
  },
  {
    companyCode: 'PING_AN',
    productCode: 'AUTO_STANDARD',
    title: 'Автострахование Ping An - Стандарт',
    content: `Комплексное автострахование Ping An защитит ваш автомобиль в Китае.

Виды покрытия:
1. ОСАГО (обязательное):
   - Ущерб третьим лицам: до 200,000 юаней
   - Медицинские расходы: до 18,000 юаней
   - Ущерб имуществу: до 2,000 юаней

2. КАСКО (добавляется):
   - Полная гибель/кража: рыночная стоимость авто
   - Частичные повреждения: полное покрытие ремонта
   - Стихийные бедствия: включены
   - Стекла и фары: отдельная опция

Стоимость ОСАГО: от 950 юаней/год
Стоимость КАСКО: 3-5% от стоимости автомобиля

Дополнительные услуги:
- Эвакуация при ДТП: бесплатно
- Помощь на дороге: 24/7
- Замена автомобиля на время ремонта: опция
- Юридическая поддержка при ДТП: включена

Скидки:
- Без ДТП 1 год: -10%
- Без ДТП 2 года: -20%
- Без ДТП 3+ года: -30%`,
  },
  {
    companyCode: 'PICC',
    productCode: 'PROPERTY_HOME',
    title: 'Страхование квартиры PICC',
    content: `Защитите свою квартиру в Китае с полисом PICC.

Что покрывается:
- Пожар и взрыв: до 2,000,000 юаней
- Затопление: до 500,000 юаней
- Кража со взломом: до 300,000 юаней
- Стихийные бедствия: до 1,000,000 юаней
- Ущерб имуществу соседей: до 500,000 юаней

Стоимость: от 800 юаней/год (зависит от площади)

Дополнительно страхуется:
- Мебель и бытовая техника
- Личные вещи
- Ремонт и отделка
- Коммуникации (трубы, проводка)

Сервисы:
- Аварийная служба 24/7
- Независимая оценка ущерба
- Оплата за ремонт напрямую подрядчикам
- Временное жилье при необходимости ремонта

Требования:
- Наличие систем безопасности (рекомендуется)
- Регулярное обслуживание коммуникаций
- Квартира не на первом этаже (для защиты от кражи)`,
  },
  {
    companyCode: 'CPIC',
    productCode: 'BUSINESS_SME',
    title: 'Страхование бизнеса CPIC для малых предприятий',
    content: `Комплексная защита вашего бизнеса в Китае с CPIC.

Базовое покрытие:
- Имущество компании: до 5,000,000 юаней
- Ответственность перед третьими лицами: до 2,000,000 юаней
- Перерыв в деятельности: до 1,000,000 юаней
- Электронное оборудование: до 500,000 юаней

Стоимость: от 15,000 юаней/год (зависит от отрасли)

Дополнительные покрытия:
- Кибер-риски: защита данных, взломы
- Ответственность директора
- Профессиональная ответственность
- Транспортировка грузов

Отрасли:
- Торговля
- IT и технологии
- Производство
- Услуги
- HoReCa

Преимущества:
- Быстрое урегулирование убытков (до 7 дней)
- Юридическое сопровождение
- Консультации по рискам
- Онлайн-кабинет для управления полисом

Требования:
- Регистрация бизнеса в Китае
- Годовой оборот до 50 млн юаней
- Отсутствие убытков за последние 3 года (желательно)`,
  },
];

async function seed() {
  console.log('🌱 Starting seed...');

  // Очищаем старые данные
  console.log('🗑️  Cleaning old data...');
  await prisma.kBChunk.deleteMany();
  await prisma.kBDoc.deleteMany();

  // Создаем тестового агента
  console.log('👤 Creating test agent...');
  const agent = await prisma.agent.upsert({
    where: { login: 'admin' },
    update: {},
    create: {
      name: 'Администратор',
      login: 'admin',
      password: 'admin123', // В продакшене нужен хеш!
      status: 'online',
      companies: 'PICC,CPIC,PING_AN',
    },
  });
  console.log('✅ Agent created:', agent.login);

  // Добавляем документы в базу знаний
  console.log('📚 Adding knowledge base documents...');
  for (const doc of sampleDocuments) {
    // Разбиваем на чанки
    const chunks = splitIntoChunks(doc.content, 500, 50);

    const kbDoc = await prisma.kBDoc.create({
      data: {
        companyCode: doc.companyCode,
        productCode: doc.productCode,
        title: doc.title,
        version: '1.0',
      },
    });

    for (let i = 0; i < chunks.length; i++) {
      await prisma.kBChunk.create({
        data: {
          docId: kbDoc.id,
          chunkIdx: i,
          text: chunks[i],
        },
      });
    }

    console.log(`✅ Added: ${doc.title} (${chunks.length} chunks)`);
  }

  console.log('✨ Seed completed successfully!');
}

function splitIntoChunks(text: string, chunkSize: number, overlap: number): string[] {
  const chunks: string[] = [];
  let start = 0;

  while (start < text.length) {
    const end = Math.min(start + chunkSize, text.length);
    chunks.push(text.substring(start, end));
    start += chunkSize - overlap;
  }

  return chunks;
}

seed()
  .catch((e) => {
    console.error('❌ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

```

```json
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^6.16.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "prisma": "^6.16.2",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

```

Теперь обновлю инструкцию по установке:

```markdown
# Настройка проекта Insurance Chat Backend

## 📋 Шаг 1: Создайте .env файл

Создайте файл `.env` в папке `backend` со следующим содержимым:

```env
DATABASE_URL="file:./dev.db"

TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"

# Опционально - для OpenAI
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o-mini"

JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"
```

## 🔧 Шаг 2: Установите зависимости

```powershell
npm install
```

## 🗄️ Шаг 3: Настройте базу данных

### Сгенерировать Prisma Client:
```powershell
npm run prisma:generate
```

### Создать миграцию БД:
```powershell
npm run prisma:migrate
```

При запросе имени миграции введите: `init`

### Заполнить базу тестовыми данными:
```powershell
npm run prisma:seed
```

Это добавит:
- 5 примеров страховых продуктов (PICC, CPIC, Ping An)
- Тестового агента (логин: admin, пароль: admin123)

## 🚀 Шаг 4: Запустите сервер

```powershell
npm run start:dev
```

## 🌐 Настройка Telegram Webhook (для локальной разработки)

### Окно №1 - Запустите туннель:
```powershell
npx localtunnel --port 3000
```

Скопируйте URL туннеля (например: `https://tangy-colts-change.loca.lt`)

### Окно №2 - Настройте webhook:
```powershell
$botToken = "8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
$publicUrl = "https://ваш-url.loca.lt"  # Вставьте URL из окна №1
Invoke-RestMethod -Uri ("https://api.telegram.org/bot{0}/setWebhook?url={1}/channels/telegram/webhook" -f $botToken, $publicUrl) -Method Get
```

### Окно №3 - Запустите сервер:
```powershell
cd backend
npm run start:dev
```

## 🛠️ Дополнительные команды

### Просмотр БД через Prisma Studio:
```powershell
npm run prisma:studio
```

### Пересоздание БД:
```powershell
# Удалите файл dev.db и папку prisma/migrations
# Затем запустите снова:
npm run prisma:migrate
```

## ✅ Проверка работы

1. Откройте Telegram бота
2. Напишите любое сообщение
3. Бот должен ответить
4. Сообщения сохраняются в БД (`dev.db`)

## 📚 Структура проекта

```
backend/
├── src/
│   ├── modules/
│   │   ├── ai/         # AI сервис (OpenAI)
│   │   ├── auth/       # Аутентификация агентов
│   │   ├── channels/   # Telegram webhook
│   │   ├── chat/       # Чат сервис
│   │   └── prisma/     # Prisma подключение
│   └── main.ts
├── prisma/
│   └── schema.prisma   # Схема БД
├── .env               # Переменные окружения
└── dev.db            # SQLite база данных
```

## 🔍 Troubleshooting

### Ошибка: "Prisma Client not generated"
```powershell
npm run prisma:generate
```

### Ошибка: "Can't reach database"
- Проверьте, что `.env` файл создан
- Проверьте путь в `DATABASE_URL`

### Webhook не работает
- Убедитесь, что туннель запущен
- Проверьте, что URL туннеля правильный в webhook
- Проверьте логи сервера на наличие ошибок


```

```markdown
# 📚 Knowledge Base (RAG) - Руководство

## Что это?

Knowledge Base с RAG (Retrieval-Augmented Generation) позволяет боту давать точные ответы на основе документов о страховых продуктах.

## Как это работает?

1. **Документы разбиваются на чанки** (фрагменты по 500 символов)
2. **Генерируются эмбеддинги** через OpenAI для семантического поиска
3. **При запросе пользователя** ищутся похожие чанки
4. **AI генерирует ответ** на основе найденной информации

## API Endpoints

### 📝 Добавить документ

```http
POST /kb/documents
Content-Type: application/json

{
  "companyCode": "PICC",
  "productCode": "TRAVEL_ANNUAL",
  "title": "Годовой туристический полис",
  "content": "Полное описание продукта...",
  "fileUrl": "https://example.com/doc.pdf",
  "sourceUrl": "https://picc.com/products/travel",
  "version": "2.0"
}
```

**Ответ:**
```json
{
  "docId": "uuid-here",
  "chunksCount": 5
}
```

### 📋 Список документов

```http
GET /kb/documents?companyCode=PICC&productCode=TRAVEL_ANNUAL
```

**Ответ:**
```json
[
  {
    "id": "uuid",
    "companyCode": "PICC",
    "productCode": "TRAVEL_ANNUAL",
    "title": "Годовой туристический полис",
    "fileUrl": "...",
    "sourceUrl": "...",
    "version": "2.0",
    "createdAt": "2025-01-01T00:00:00Z",
    "_count": {
      "chunks": 5
    }
  }
]
```

### 🔍 Поиск по базе знаний

```http
POST /kb/search
Content-Type: application/json

{
  "query": "Сколько стоит медицинская страховка?",
  "companyCode": "CPIC",
  "limit": 3
}
```

**Ответ:**
```json
[
  {
    "text": "Премиум медицинский полис CPIC - максимальная защита здоровья...",
    "score": 0.87,
    "docTitle": "Премиум медицинское страхование CPIC",
    "companyCode": "CPIC",
    "productCode": "MEDICAL_PREMIUM"
  }
]
```

### 🗑️ Удалить документ

```http
DELETE /kb/documents/:id
```

## Примеры использования

### PowerShell

#### Добавить документ:
```powershell
$body = @{
  companyCode = "PICC"
  productCode = "TRAVEL_ANNUAL"
  title = "Годовой туристический полис"
  content = "Годовой туристический полис PICC обеспечивает..."
} | ConvertTo-Json

Invoke-RestMethod -Uri "http://localhost:3000/kb/documents" -Method Post -Body $body -ContentType "application/json"
```

#### Поиск:
```powershell
$body = @{
  query = "Сколько стоит страховка для туристов?"
  limit = 3
} | ConvertTo-Json

Invoke-RestMethod -Uri "http://localhost:3000/kb/search" -Method Post -Body $body -ContentType "application/json"
```

### Curl

#### Добавить документ:
```bash
curl -X POST http://localhost:3000/kb/documents \
  -H "Content-Type: application/json" \
  -d '{
    "companyCode": "PICC",
    "productCode": "TRAVEL_ANNUAL",
    "title": "Годовой туристический полис",
    "content": "Годовой туристический полис PICC обеспечивает..."
  }'
```

#### Поиск:
```bash
curl -X POST http://localhost:3000/kb/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "Сколько стоит страховка для туристов?",
    "limit": 3
  }'
```

## Как бот использует RAG

Когда пользователь пишет боту, система:

1. **Ищет релевантные документы** по запросу
2. **Передает найденную информацию в AI**
3. **AI генерирует ответ** только на основе документов
4. **Если документов нет** - предлагает связаться с агентом

### Пример работы:

**Пользователь:** "Сколько стоит годовая туристическая страховка?"

**Система:**
1. Ищет в KB документы про туристическую страховку
2. Находит "Годовой страховой полис для туристов в Китай" (PICC)
3. AI отвечает: "Годовой туристический полис PICC стоит от 2,500 юаней в год..."

## Управление базой знаний

### Через Prisma Studio:
```powershell
npm run prisma:studio
```

Откроется веб-интерфейс на http://localhost:5555 где можно:
- Просматривать документы
- Редактировать чанки
- Удалять записи

### Через API:

См. примеры выше.

## Тестовые данные

После `npm run prisma:seed` в БД будут:

1. **PICC - Туристический полис** (TRAVEL_ANNUAL)
2. **CPIC - Медицинская страховка** (MEDICAL_PREMIUM)
3. **Ping An - Автострахование** (AUTO_STANDARD)
4. **PICC - Страхование квартиры** (PROPERTY_HOME)
5. **CPIC - Страхование бизнеса** (BUSINESS_SME)

## Настройка эмбеддингов

Для работы векторного поиска нужен **OpenAI API ключ** в `.env`:

```env
OPENAI_API_KEY="sk-your-api-key"
```

Используется модель: `text-embedding-3-small` (1536 измерений)

### Без API ключа:

Система будет работать, но поиск будет базовым (все результаты с score=0).
Для тестирования можно обойтись без ключа.

## Производительность

### Кеширование эмбеддингов:

Эмбеддинги чанков кешируются в памяти для ускорения поиска.

### Оптимизация:

Для больших баз знаний (1000+ документов) рекомендуется:
- Использовать векторную БД (Pinecone, Weaviate, Qdrant)
- Хранить эмбеддинги в отдельной таблице
- Использовать индексы для быстрого поиска

## Улучшения (TODO)

- [ ] Поддержка PDF/DOCX файлов
- [ ] Автоматическое обновление эмбеддингов
- [ ] Векторная БД вместо in-memory поиска
- [ ] Мультиязычность (английский, китайский)
- [ ] Версионирование документов
- [ ] История изменений

```

Теперь создам краткий README с описанием новой функциональности:

```markdown
# 🎉 Knowledge Base + RAG - Готово!

## Что добавлено?

### 1. **Knowledge Base модуль** 📚
- Управление базой знаний о страховых продуктах
- Автоматическая разбивка документов на чанки
- API для добавления/удаления/поиска документов

### 2. **Векторный поиск** 🔍
- Семантический поиск через OpenAI embeddings
- Косинусное сходство для ранжирования результатов
- Кеширование эмбеддингов для производительности

### 3. **RAG интеграция** 🤖
- AI отвечает на основе документов из базы знаний
- Точные ответы о страховых продуктах
- Автоматический fallback если информации нет

### 4. **Тестовые данные** ✅
- 5 готовых примеров страховых продуктов
- Полное описание покрытий и цен
- Тестовый агент для админки

## Быстрый старт

### 1. Создайте `.env`:
```env
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="ваш-токен"
OPENAI_API_KEY="ваш-ключ-openai"
JWT_SECRET="секретный-ключ"
```

### 2. Установите и запустите:
```powershell
cd insurance-chat/backend
npm install
npm run prisma:generate
npm run prisma:migrate
npm run prisma:seed
npm run start:dev
```

### 3. Протестируйте бота:
Напишите в Telegram боту: **"Сколько стоит туристическая страховка?"**

Бот найдет информацию в базе знаний и ответит точно! 🎯

## Структура проекта

```
backend/
├── src/modules/
│   ├── kb/                    # ⭐ НОВЫЙ: Knowledge Base
│   │   ├── kb.service.ts      # Логика RAG
│   │   ├── kb.controller.ts   # API endpoints
│   │   └── kb.module.ts
│   ├── ai/
│   │   └── ai.service.ts      # ⭐ ОБНОВЛЕН: RAG интеграция
│   ├── chat/
│   │   └── chat.service.ts    # ⭐ ОБНОВЛЕН: Prisma БД
│   ├── channels/
│   │   ├── telegram.controller.ts
│   │   └── channels.module.ts # ⭐ ОБНОВЛЕН: KB импорт
│   └── prisma/                # ⭐ НОВЫЙ: Prisma модуль
│       ├── prisma.service.ts
│       └── prisma.module.ts
├── prisma/
│   ├── schema.prisma          # ⭐ ИСПРАВЛЕН: Relations
│   └── seed.ts                # ⭐ НОВЫЙ: Тестовые данные
├── SETUP.md                   # ⭐ Инструкция по установке
├── KB_GUIDE.md                # ⭐ Руководство по KB
└── README_RAG.md              # ⭐ Этот файл
```

## API Endpoints

### Knowledge Base:

- `POST /kb/documents` - Добавить документ
- `GET /kb/documents` - Список документов
- `DELETE /kb/documents/:id` - Удалить документ
- `POST /kb/search` - Поиск по базе

Подробнее: [KB_GUIDE.md](./KB_GUIDE.md)

### Chat (существующие):

- `POST /chat/sessions` - Создать сессию
- `POST /chat/messages` - Отправить сообщение
- `GET /chat/messages/:sessionId` - История сообщений

### Telegram Webhook:

- `POST /channels/telegram/webhook` - Webhook для Telegram

## Тестовые данные

После seed доступны:

| Компания | Продукт | Описание | Цена |
|----------|---------|----------|------|
| PICC | TRAVEL_ANNUAL | Годовой туристический полис | от 2,500¥/год |
| CPIC | MEDICAL_PREMIUM | Премиум медицинская страховка | от 8,000¥/год |
| Ping An | AUTO_STANDARD | Автострахование ОСАГО+КАСКО | от 950¥/год |
| PICC | PROPERTY_HOME | Страхование квартиры | от 800¥/год |
| CPIC | BUSINESS_SME | Страхование малого бизнеса | от 15,000¥/год |

## Примеры вопросов для тестирования

Спросите бота в Telegram:

1. **"Сколько стоит туристическая страховка?"**
   → Найдет PICC TRAVEL_ANNUAL

2. **"Что покрывает медицинская страховка CPIC?"**
   → Найдет CPIC MEDICAL_PREMIUM

3. **"Нужна страховка на машину"**
   → Найдет Ping An AUTO_STANDARD

4. **"Как застраховать квартиру?"**
   → Найдет PICC PROPERTY_HOME

5. **"Страхование для бизнеса"**
   → Найдет CPIC BUSINESS_SME

## Как это работает?

```
Пользователь: "Сколько стоит медицинская страховка?"
        ↓
1. Telegram отправляет сообщение → TelegramController
        ↓
2. Сохраняется в БД → ChatService (Prisma)
        ↓
3. Генерируется embedding запроса → KbService
        ↓
4. Ищутся похожие документы (cosine similarity)
        ↓
5. Найденные чанки передаются в AI → AiService
        ↓
6. AI генерирует ответ на основе документов
        ↓
7. Ответ отправляется пользователю и сохраняется в БД
```

## Что дальше?

### Следующие улучшения:

1. **Веб-виджет** - чат для сайта
2. **Админ-панель** - управление чатами и KB
3. **Handover** - передача от AI к агенту
4. **Voice** - голосовые сообщения
5. **Интеграция polis.online** - оформление полисов

### Оптимизация RAG:

1. Векторная БД (Pinecone/Qdrant)
2. Хранение эмбеддингов в Prisma
3. Индексы для быстрого поиска
4. Batch processing для больших объемов

## Troubleshooting

### Бот отвечает "нет информации"
- Проверьте, что seed выполнен: `npm run prisma:seed`
- Проверьте OPENAI_API_KEY в `.env`

### Поиск не работает
- Убедитесь, что OPENAI_API_KEY валиден
- Проверьте баланс OpenAI аккаунта
- Посмотрите логи сервера на наличие ошибок

### База данных не создается
- Удалите `dev.db` и `prisma/migrations`
- Запустите снова: `npm run prisma:migrate`

## Документация

- [SETUP.md](./SETUP.md) - Полная инструкция по установке
- [KB_GUIDE.md](./KB_GUIDE.md) - Руководство по Knowledge Base
- [Prisma Docs](https://www.prisma.io/docs) - Документация Prisma
- [OpenAI Embeddings](https://platform.openai.com/docs/guides/embeddings) - OpenAI эмбеддинги

---

**Создано:** 1 октября 2025
**Технологии:** NestJS, Prisma, SQLite, OpenAI, RAG, Telegram Bot API

```

Отлично! Давайте проверим код на ошибки:

Превосходно! Все готово без ошибок! 🎉

---

## ✨ Что я сделал:

### 1. **Knowledge Base модуль** 📚
- ✅ `KbService` - управление базой знаний
- ✅ `KbController` - REST API для документов
- ✅ Векторный поиск с эмбеддингами OpenAI
- ✅ Автоматическая разбивка текста на чанки

### 2. **RAG интеграция** 🤖
- ✅ `AiService` обновлен - использует базу знаний
- ✅ Семантический поиск по документам
- ✅ AI отвечает на основе реальных данных
- ✅ Fallback если информации нет

### 3. **Тестовые данные** 🗂️
- ✅ 5 страховых продуктов (PICC, CPIC, Ping An)
- ✅ Полные описания с ценами и условиями
- ✅ Seed скрипт для быстрого запуска
- ✅ Тестовый агент (admin/admin123)

### 4. **Документация** 📖
- ✅ `SETUP.md` - полная инструкция установки
- ✅ `KB_GUIDE.md` - руководство по KB API
- ✅ `README_RAG.md` - обзор новой функциональности

---

## 🚀 Что делать дальше:

### **Шаг 1:** Создайте `.env` файл

Создайте файл `insurance-chat/backend/.env`:

```env
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
OPENAI_API_KEY="ваш-ключ-openai"
JWT_SECRET="your-secret-key"
```

> ⚠️ **Важно:** Для работы RAG нужен `OPENAI_API_KEY`

### **Шаг 2:** Инициализируйте БД

```powershell
cd insurance-chat\backend
npm install
npm run prisma:generate
npm run prisma:migrate
```

При запросе имени миграции: **`init`**

### **Шаг 3:** Загрузите тестовые данные

```powershell
npm run prisma:seed
```

Это добавит 5 страховых продуктов в базу знаний.

### **Шаг 4:** Запустите сервер

```powershell
npm run start:dev
```

### **Шаг 5:** Протестируйте RAG!

Напишите боту в Telegram:
- **"Сколько стоит туристическая страховка?"**
- **"Что покрывает медицинская страховка?"**
- **"Нужна страховка на машину"**

Бот теперь отвечает на основе реальных документов! 🎯

---

## 📊 Архитектура RAG

```
Telegram → TelegramController
              ↓
         ChatService (сохранение в БД)
              ↓
         KbService.search() ← генерирует embedding запроса
              ↓
         Находит похожие документы
              ↓
         AiService (RAG) ← передает документы в GPT
              ↓
         Ответ пользователю + сохранение в БД
```

---

## 🎯 Следующие шаги развития:

1. **Веб-виджет** - чат для встраивания на сайт
2. **Админ-панель** - управление чатами и документами
3. **Handover** - передача от AI к живому агенту
4. **Voice** - голосовые сообщения
5. **polis.online** - оформление полисов через API

**Что хотите сделать следующим?** 😊

```plaintext
DATABASE_URL="file:./dev.db"
TELEGRAM_BOT_TOKEN="8279197548:AAGXNdEXKQUVBoK_qY2D8dAZWjdzSl1qhmQ"
OPENAI_API_KEY="ваш-ключ-openai"
JWT_SECRET="your-secret-key"
```

```powershell
cd insurance-chat\backend
npm install
npm run prisma:generate
npm run prisma:migrate
```

```powershell
npm run prisma:seed
```

```powershell
npm run start:dev
```

```plaintext
Telegram → TelegramController
              ↓
         ChatService (сохранение в БД)
              ↓
         KbService.search() ← генерирует embedding запроса
              ↓
         Находит похожие документы
              ↓
         AiService (RAG) ← передает документы в GPT
              ↓
         Ответ пользователю + сохранение в БД
```

